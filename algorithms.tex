% -*- coding: utf-8 -*-

\section{Algorithms}
\label{algorithms}
\subsection{Introduction}
In this section I will go into high-level detail about the principal problems that are to be solved in this project, as well as the algorithms that I have used to solve them. With each algorithm I will include an explanation of their use, an analysis of the algorithms run-time, as well as a discussion of possible alternatives. 

\subsection{Intersection}
In order to be able to use the Rectangular Swept Sphere (RSS) in the [whatever] \Sfixme{find name of framework}, it is paramount that I must find a fast way to detect when 2 RSS' are intersecting, so that it can be decided whether a fold of the protein should go ahead or not. In the following I will describe the methods I have used to check whether or not two RSS' are intersecting.

\subsubsection{Approach}
In the algorithm I have chosen to implement, I will prefer to report a possible intersection where there might not be one, instead of failing to report a possible overlap. While this may give a performance penalty, since the system might have to perform more checks, it is critically important that illegal configurations of the proteins are not accepted. 

\subsubsection{Minimum distance}
In the following let minDist(rec(A), rec(B)) be the minimum distance between the rectangles of RSS A and B, radius(A) is the radius of A.\\

One approach to check if 2 Rectangular Swept Spheres, A and B, overlap, is to check the minimum distance between their rectangles. It is clear that if minDist(rec(A), rec(B)) $<=$ Radius(A) + radius(B) \Sfixme{implement in code and show illustation}, then A and B overlaps. This is the approach found in \cite{Larsen99fastproximity}.

The problem then becomes one of finding the 2 closest points, and calculating the distance.
Given that the rectangles do not overlap, then the possible configurations of the closest points are, according to section 4.2.1 of \cite{Larsen99fastproximity}:
\begin{enumerate}
\item Both of the points lie on an edge
\item One of the points lie in the interior of one of the rectangles, while the other either lies on the other rectangles edge or interior.
\end{enumerate}

\subsection{The points lie on 2 edges}
\label{minimumDistance}
Since we are only interested in the smallest minimum distance between the edges, it is clear that we only have calculate the minimum distance between the edges that are closest to each other. The approach in my implementation is the one described in \cite{larsen00fast} and \cite{Larsen99fastproximity}, where the authors exploit the properties of Voronoi diagrams\footnote{For a formal description of Voronoi diagrams see \cite{compgeom:2008} Chapter 7} in order to quickly decide which pair of edges are possible candidate for the smallest distance. For a more detailed justification of this, see \cite{larsen00fast} section 4.2 and \cite{Larsen99fastproximity} section 4.3.1 - particularly Lemma 1.

Fortunately one does not need to calculate the Voronoi diagram in order to detect which Voronoi cell an edge lies in. Let E be the edge whoose closest edges we wish to find, \textbf{n} be the perpendicular vector to E, then the face defined by -\textbf{n} and a point on E will define the half-plane D. All edges that lies, wholey or partly, lies within D are candiates for the closest edge \cite{larsen00fast} \Sfixme{Check that I do not perform plagerism}. However, this has the minor disadvantage that an edge might lie in multiple half-planes, but even in the worst case this would mean that 8 checks would have had to be made (2 checks for each edge), which clearly is better than 16 checks.\Sfixme{perhaps there should be an image illustrating this - yes there proberly should}

The problem then becomes one of finding the minimum distance between 2 line-segments in 3 dimensions, and then returning the smallest of these values. If no possible candidates are found, then infinity is returned.

If RSS' overlap, the closets point the points with the minimum distance to the  , or the minimum distance between the 2 RSS is greater than the maximum radius, then it becomes necessary to run the separating axis test, which is described below\Sfixme{This can be formulated better}.

\subsection{Separating axis test}
\label{sepAxis}
In order to take care of the cases where 2 rectangles either overlap or where the closest point lies inside the interior of the rectangles, I have to do an Axis-separation check, as described in \cite{237244}. The gist of the Axis-separation test is ``that two disjoint convex polytopes in 3-space can always be separated by a plane which is parallel to a face of either polytope, or parallel to an edge from each polytope'' (\cite{237244}, section 5, page. 8). If one or more Axis-separation shows that there might be an overlap, then the system will report that further test are needed.

The Axis-separation test described in \cite{237244} was designed to work on Oriented Bounding Boxes (OBB's), and takes care of rectangle to rectangle axis test as a degenerate case (\cite{237244}, section 5), which is faster. 

However, since each RSS has a radius, it became a question during implementation whether the system should assume that the two objects it was comparing should be treated OBB's (with a length, a width and a height), or if they were rectangles (with only a length and a width). In the end I choose to implement the axis test to take care of OBB's, and treat the overlap for rectangles as a special case (where the height of the two rectangles are 0).

\subsubsection{Order of Minimum distance and Axis separating test}
\label{minAxisOrder}
A pertinent question might be whatever the order of the tests are optimal, or whether it might be better just to run the axis separation test.

In order to have this discussion make any sense, it is important to understand the purpose and the exiting condition for both methods:

\begin{description}
\item[Minimum Distance:] The minimum distance algorithm tries to find all the minimum distances it can find. 
Local best case: None of the edges lies in the half-planes that indicates the  Voronoi cells\Sfixme{other description?}, and it terminates, having found the minimum distance between no edges. The exiting condition of the algorithm is when it either has checked all Voronoi cells \Sfixme{description again?} and calculated all the minimum distances, or when it finds a minimum distance that is smaller than the combined radius of the two RSS' \Sfixme{implement this in the code}. If the algorithm returns with a positive, then we know that the 2 RSS' intersect, but if it returns with a negative, then we do not know whether the 2 RSS' overlap or not. The algorithm favours the cases where the 2 RSS' might overlap.  

\item[Axis Separating:] The axis separation algorithm tries to find an axis that separates the 2 RSS'. In the best case, the first axis will show that the two RSS' are disjoint, and the algorithm terminates. In the worst case the 2 RSS' are not independent, and all 15 (6 axis tests for 3 faces from each box in the RSS \Sfixme{explain definition of RSS back in appropriate section} + 9 axises that are created by a combination of the 3 face vectors from each box\Sfixme{reformulate!}) test have to be made. The algorithm favours the cases where the 2 RSS' are disjoint.
\end{description}

From this it is clear that the order of the algorithm we choose will be influenced by which cases we believe to be the most common, as well as which cases we think of as the most likely. If we think that the 2 RSS' will often be above each other, or that the RSS' often will be separated, then it will be better to only run the Axis-separation test. If on the other hand we believe that RSS' won't be placed above each other, and that they often intersect, then the minimum distance algorithm, followed by the Axis-separation test is preferred.

Since in the context of folding proteins are interested in being told that a fold is illegal as soon as possible (so that the next fold can be tested), I think that first running the Minimum distance algorithm, and then the Axis-separation test would improve the run-time on average\Sfixme{is it average, or is it something else} compared to if we only ran the Axis-separation test.

\subsection{Heuristic for creating RSS for multiple points}
In order for the RSS to be a useful data-structure, it is clear that, given a set of points, we must be able to construct a RSS that contains all of the points. If this was not the case, then we would be unable to use RSS in a Bounding Volume Hierarchy\Sfixme{reference to text and page}.

\Sfixme{Co-variance or just wing it?}
