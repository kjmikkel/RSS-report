% -*- coding: utf-8 -*-

\section{Implementation}
\label{implementation}

\subsection{Introduction}
In this section I will give an overview of the implementation details of this projects. This will include choice of programming language, a discussion about the possible algorithms that could have been used \Sfixme{should this part be in the algorithm section, and if so should there be an reordering of the sections?}, extra libraries that I have found useful, as well as an overview of the classes and files that I have added to the framework.

\subsection{Choice of programming language}
Since the goal of this project is to implement the Rectangular Swept Sphere into the [whatever] \fixme{what is the framework called - found out} Java framework, there has never been any doubt that as much as possible of this project should be implemented in Java - only using other languages if there were already existing, and efficient code, that implemented critical features, which were to much work to be implemented.

\subsection{Use of Framework}
Since this project is about implementing RSS in to [whatever framework], I will make heavy use of the features already existing in the framework. This will be done both to save time and avoid code duplication, but also under the assumption that the implemented features will be more efficient than what I myself could implement.

\subsection{Possible choice of algorithms}
\subsubsection{Proximity detection}
In the following let minDist(rec(A), rec(B)) be the minimum distance between the rectangles of RSS A and B, and max(radius(A), radius(B)) be the biggest radius of A and B.\\

One approach to check if 2 Rectangular Swept Spheres, A and B, overlap, is to check the proximity of their rectangles. It is clear that if minDist(rec(A), rec(B)) $<=$ max(Radius(A), radius(B)), then A and B overlaps. This is the approach found in \cite{Larsen99fastproximity}.

The problem then becomes one of finding the 2 closest points, and calculating the distance.
If the rectangles of A and B does not overlap, the closest points, as described in section 4.2.1 of \cite{Larsen9fastproximity}, lies:
\begin{enumerate}
\item on 2 edges
\item in the interior of one of the rectangles
\end{enumerate}

\subsection{Between 2 edges}
Since we are only interested in the smallest minimum distance between the edges, it is clear that we only have calculate the minimum distance between the edges that are closest to each other. The approach in my implementation is the one described \cite{Larsen99fastproximity}, where the authors exploit the properties of Voronoi diagrams\footnote{For a formal description of Voronoi diagrams see \cite{compgeom:2008} Chapter 7} to quickly decide which pair of edges are worth testing. For a more detailed justification of this, see \cite{Larsen99fastproximity} section 4.3.1 - particularly Lemma 1.  

Fortunately one does not need to calculate the Voronoi diagram in order to find whether an edge lies in another edges Voronoi cell. Instead, it can be done by checking which edges lies within the half-plane created by the edge.

In the following, let e be the edge in A whose closest edges we want to find.  
In practice I exploit the Voronoi properties, I create the needed plane P by taking e's vector and a point in e, and check which endpoints of the edges in B lies above\Sfixme{does this make sense? I mean sure code wise, but what is the correct termanoligy?} P. The minimum distance between these edges are then found (which resolves into the problem of finding the minimum distance between 2 line-segments).

This process is repeated for all the edges and the smallest of the minimal distances is returned. If the smallest minimal distance is smaller than the radius of the RSS, then there might be an overlap, and further tests are needed.

If no minimum distance is found, or if parts of an edge is found to be above P, and some of it below P, then it will be necesary to runt he Seperating axis test, which is described below.

\subsection{Separating axis test}
\label{sepAxis}
In order to take care of the cases where the 2 rectangles either overlap or where the closest point lies inside the interior of the rectangles, I have to do an Axis-separation check, as described in \cite{237244}. The gist of the Axis-separation test is ``that two disjoint convex polytopes in 3-space can always be separated by a plane which is parallel to a face of either polytope, or parallel to an edge from each polytope'' (\cite{237244}, section 5, page. 8). If one or more Axis-seperation shows that there might be an overlap, then the system will report that further test are needed.

The Axis-separation test described in \cite{237244} was designed to work on Oriented Bounding Boxes (OBB's), and takes care of rectangle to rectangle axis test as a degenerate case (\cite{237244}, section 5), which is faster. 

However, since each RSS has a radius, it became a question during implementation whether the system should assume that the two objects it was comparing should be treated OBB's (with a length, a width and a height), or if they were rectangles (with only a length and a width). In the end I choose to implement the axis test to take care of OBB's, and treat the overlap for rectangles as a special case (where the height of the two rectangles are 0).

\subsection{Heuristic for creating RSS for multiple points}
